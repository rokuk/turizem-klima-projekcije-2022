---
title: "HCI"
author: "Rok Kuk"
output: github_document
---

This code reads data from netcdf files, downloaded from [CDS](https://cds.climate.copernicus.eu/cdsapp#!/dataset/sis-tourism-climate-suitability-indicators?tab=overview) and makes plots for selected stations showing HCI values
under different RCP scenarios.

```{r}
Sys.time()
library(ncdf4)
library(fields)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(plotly)
sessionInfo()
```

The datasets are saved in netcdf files. We define a function that opens the file, 
reads longitude, latitude, rotated longitude, rotated latitude, the number of days.
Only the data near Slovenia is read to conserve memory.

```{r}
readcdf <- function(filepath, datavarname) {
    nc_data <- nc_open(filepath)

    rlonstart = 215
    rlatstart = 150
    loncount = 45
    latcount = 40
    
    lon <- ncvar_get(nc_data, "lon", start=c(rlonstart, rlatstart), count=c(loncount, latcount))
    lat <- ncvar_get(nc_data, "lat", start=c(rlonstart, rlatstart), count=c(loncount, latcount))
    rlon <- ncvar_get(nc_data, "rlon", start=c(rlonstart), count=c(loncount))
    rlat <- ncvar_get(nc_data, "rlat", start=c(rlatstart), count=c(latcount))

    data.array <- ncvar_get(nc_data, datavarname, start=c(rlonstart, rlatstart, 1), count=c(loncount, latcount, -1))
    
    nc_close(nc_data)
    
    returnlist <- list("lon" = lon, "lat" = lat, "rlon" = rlon, "rlat" = rlat, "data"=data.array)
    
    return (returnlist)
}
```

Read one file to get the model's grid:

```{r}
netcdfdata <- readcdf("../podatki/HCI/historical/mean/C3S422Lot2TEC_day-fair-hci-month-proj_mean_monthly_1986_2005_v1.nc", "day-fair-hci-month-proj")
```

Plot june data centered on Slovenia, to check if we have the right rlon, rlat range:

```{r}
p <- image.plot(netcdfdata$rlon, netcdfdata$rlat, netcdfdata$data[,,6])
```

Datapoints in the netcdf file use rotated lon and lat coordinates. We need regular longitude and latitude. The file also contains a table of lon(rlon, rlat) and a table of lat(rlon, rlat) coordinates for conversion. We compose a data frame with longitude, latitude and number of days.

```{r}
month_names = c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "okt", "nov", "dec")
transform_coordinates <- function(netcdfdata) {
    lons = c()
    lats = c()
    datapoints = c()
    months = c()
    ids = c()
    count = 0
    
    for (i in 1:length(netcdfdata$rlon)) {
        for (j in 1:length(netcdfdata$rlat)) {
            count <- count + 1
            ids <- c(ids, rep(count, 12))
            lons <- c(lons, rep(netcdfdata$lon[i,j], 12))
            lats <- c(lats, rep(netcdfdata$lat[i,j], 12))
            months <- c(months, month_names)
            datapoints <- c(datapoints, netcdfdata$data[i, j,])
        }
    }

    return (data.frame(
        id=ids,
        lon=lons,
        lat=lats,
        month=months,
        datapoint=datapoints
    ))
}
grid <- transform_coordinates(netcdfdata)
```

Download data for map:

```{r}
mapdata <- ne_load(scale = 10, type = 'countries', category = 'cultural', returnclass = "sf", destdir = paste(getwd(), "/geodata", sep=""))
# map data can be redownloaded to the geodata folder with:
#mapdata <- ne_download(scale = 10, type = 'countries', category = 'cultural', returnclass = "sf", destdir = paste(getwd(), "/geodata", sep=""))
```

Plot map and the model's grid:

```{r}
ggplot(mapdata) +
    geom_sf() +
    coord_sf(xlim=c(5, 23), ylim=c(40, 52)) + 
    geom_point(data=grid, mapping = aes(lon, lat), size=0.2) +
    theme_dark()
```


Import coordinates of the stations we are interested in:

```{r}
stationcoords <- read.csv("../podatki/postaje.csv")
print(stationcoords)
```

We choose points on the grid, which are as near as possible to each station. The chosen points:

```{r}
names <- c("Rateče", "Bilje", "Koper", "Ljubljana", "Novo mesto", "Celje", "Slovenj Gradec", "Maribor", "Murska Sobota")
nearest_point_indexes <- c(706, 661, 698, 902, 1060, 1064, 1066, 1186, 1347)
for (i in 1:length(nearest_point_indexes)) {
    if (i == 1) print(sprintf("%-20s %-20s %s", "station", "lat", "lon"))
    print(sprintf("%-20s %-20f %f", names[i], grid[nearest_point_indexes[i],]$lat, grid[nearest_point_indexes[i],]$lon))
}
```

Plot map of Slovenia, model grid (black), selected stations (red), selected grid points (blue):

```{r}
p<-ggplot(mapdata) +
    geom_sf() +
    coord_sf(xlim=c(13.1, 16.6), ylim=c(45.3, 47)) + 
    geom_point(data=grid, mapping = aes(lon, lat), size=0.2) +
    geom_point(data=stationcoords, mapping = aes(lon, lat), color="red") +
    geom_point(data=grid[grid$id %in% nearest_point_indexes,], mapping = aes(lon, lat), color="blue") +
    theme_dark()

ggplotly(p)
```


## Assembling data

Now we read data from all netcdf files at selected grid points and assemble it into a single dataframe (`alldata`) for plotting. Grid points are the same for all datasets. 

```{r cache=TRUE}
scenarios <- c("RCP2.6", "RCP4.5", "RCP8.5")
time_periods <- c("2021_2040", "2041_2060", "2081_2100")
day_categories <- c("fair", "good", "unf")
metrics <- c("mean", "10prct", "90prct")

datacolnames <- c("stationid", "scenario", "time_period", "metric", "day_cat", "month", "datapoint")
alldata <- data.frame(matrix(ncol = 6, nrow = 0)) # create empty dataframe

# read and extract historical data
for (metric in metrics) {
    for (day_cat in day_categories) {
        print(paste("historical", "1986_2005", metric, day_cat))
        filepath <- paste("../podatki/HCI/historical/", metric, "/C3S422Lot2TEC_day-" , day_cat, "-hci-month-proj_", metric, "_monthly_1986_2005_v1.nc", sep = "")
        datavarname <- paste("day-", day_cat, "-hci-month-proj", sep="")
        dataset <- readcdf(filepath, datavarname) %>% transform_coordinates() %>% filter(id %in% nearest_point_indexes)
        alldata <- rbind(alldata, data.frame(
            stationid=dataset$id, 
            scenario="historical", 
            time_period="1986-2005", 
            metric=metric, 
            day_cat=day_cat, 
            month=dataset$month, 
            datapoint=dataset$datapoint))
    }
}

# read and extract RCP2.6, RCP4.5 and RCP8.5 data
for (scenario in scenarios) {
    for (time_period in time_periods) {
        for (metric in metrics) {
            for (day_cat in day_categories) {
                print(paste(scenario, time_period, metric, day_cat))
                filepath <- paste("../podatki/HCI/", scenario, "/", metric, "/C3S422Lot2TEC_day-" , day_cat, "-hci-month-proj_", metric, "_monthly_", time_period, "_v1.nc", sep = "")
                datavarname <- paste("day-", day_cat, "-hci-month-proj", sep="")
                dataset <- readcdf(filepath, datavarname) %>% transform_coordinates %>% filter(id %in% nearest_point_indexes)
                alldata <- rbind(alldata, data.frame(
                    stationid=dataset$id, 
                    scenario=scenario, 
                    time_period=sub("_", "-", time_period), 
                    metric=metric, 
                    day_cat=day_cat, 
                    month=dataset$month, 
                    datapoint=dataset$datapoint))
            }
        }
    }
}
```

All relevant data is in `alldata`, where column `stationid` is the index of 
the grid point in the raw imported data, `scenario` is either "historical", 
"RCP2.6", "RCP4.5" or "RCP8.5", `time_period` is either "1986-2005", "2021-2040", 
"2041-2060" or "2081-2100", `metric` is the mean, 10th percentile or 90 
percentile, `day_cat` is either "fair", "good" or "unf" (category determined based upon CIT value), `datapoint` is the average count of days in `day_cat` category for a specific month, 
`month` is the month for which the datapoint was calculated.

```{r}
head(alldata)
```

## Plots

Define a function to calculate min and max y position for errorbars in a stacked barplot:

```{r}
adderrorbars <- function(subset) {
    means <- subset[subset$metric=="mean",]
    prct10 <- subset[subset$metric=="10prct",]
    prct90 <- subset[subset$metric=="90prct",]
    means$prct10 <- prct10$datapoint
    means$prct90 <- prct90$datapoint

    means_fair.mean <- filter(means, day_cat=="fair")$datapoint
    means_good.mean <- filter(means, day_cat=="good")$datapoint
    
    means_fair <- filter(means, day_cat == "fair") %>%
        mutate(lower = prct10,
               upper = prct90)
    
    means_good <- filter(means, day_cat == "good") %>%
        mutate(lower = means_fair.mean + prct10,
               upper = means_fair.mean + prct90)

    means_unf <- filter(means, day_cat == "unf") %>%
        mutate(lower = means_fair.mean + means_good.mean + prct10,
               upper = means_fair.mean + means_good.mean + prct90)

    return (rbind(means_fair, means_good, means_unf))
}
```

Define a function to plot data for specific point (`stat_id`) and scenario (`scen`):

```{r} 
plotdata <- function(stat_id, scen, alldata) {
    subset <- filter(alldata, stationid == stat_id & (scenario == scen | scenario ==         "historical")) %>% adderrorbars()
    
    p <- ggplot(data=subset,
        mapping=aes(x=time_period, y=datapoint, fill=factor(day_cat, levels=c("unf", "good", "fair")))) +
        geom_col() +
        geom_errorbar(mapping=aes(ymax=upper, ymin=lower, color=factor(day_cat, levels=c("unf", "good", "fair"))), stat="identity", width=0.5) + # to disable errorbars comment this line
        scale_colour_manual(values = c("#1C678D", "#AA5A00", "#006147"), guide="none") + # errorbar color
        facet_grid(~factor(month, levels=month_names)) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.02)), breaks = c(0, 5, 10, 15, 20, 25, 30, 35)) +
        guides(x = guide_axis(angle = 90)) +
        labs(title=names[match(stat_id, nearest_point_indexes)],
             subtitle = scen, fill="CIT category") +
        xlab("period") +
        ylab("days per month") +
        scale_fill_manual(values = c("#4CACDC", "#EAAA00", "#009E73")) +
        theme(axis.text.x = element_text(size = 10), axis.text.y = element_text(size=10))
    
    return (p)
}
```